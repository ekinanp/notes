NOTE: This chapter is also useful to get set-up with a basic Puppet infrastructure.

## Prelude

Chapter 1 focused on simple Puppet manifests that can be applied on any machine via. `puppet apply`. But this is not the most common way to use Puppet. Instead, one uses the server/agent architecture.

The server/agent architecture generally requires you to install the Puppet agent software on all nodes under your infrastructure and have them call your `server`, which is another Puppet installation. The `server` compiles the appropriate manifests and remotely controls the agents to sync. their machines with what's in the catalog generated by that manifest. The agent and the server authenticate themselves using SSL certificates.

## The Puppet Server

The server is the central source of config. data and authority. It performs the following tasks:
* Storing manifests and compiling catalogs
* Serving as the SSL certification authority
* Processing reports from the agent machines
* Gathering and storing information about the agents

Upon initialization, `puppetserver` generates the CA certificate that is distributed and trusted amongst all components in your infrastructure. New agent machines request individual certificats that are signed with the CA certificate.

The Puppet master service is a RESTful HTTP API. Agents initiate HTTPS transactions, where both sides identify each other via. trusted SSL certificates. `puppetserver` handles the HTTPS part.

The master port is 8140. Note that `puppetserver` needs 2 GB of memory.

## Creating the master manifest

The master compiles manifests for a lot of machines, but the agent doesn't choose which source file is used -- that is decided by the master. Any compilation by the master starts at the site manifest, which is found in `/opt/puppetlabs/code/environments/production/manifests/`.

Each connecting agent uses all of the manifests found there. To define a piece of manifest exclusively for a specific agent, put it in a `node` block. This block's contents will only be considered when the calling agent has a matching common name in its SSL certificate (just use the agent's fqdn). For example

```
node 'agent' {
  $packages = [ 'apache2',
    'libapache2-mod-php5',
    'libapache2-mod-passenger', ]
  package { $packages:
    ensure => 'installed',
    before => Service['apache2'],
  }
  service { 'apache2':
    ensure => 'running',
    enable => true,
  }
}
```

Note that it doesn't matter what domain name you choose for the master, so long as:
* All of the agent machines can resolve that name to an address
* The master process is listening for connections on that address
* The master uses a certificate with the chosen name as the CN or DNS Alt Names

The `puppetserver` listens on all available addresses by default. Note that each time you change the master's certname, all agents will need to generate new certificates for the master to sign.

## The agent's life cycle

In a Puppet-centric workflow, all changes to the configuration of servers (or machines) should be on the Puppet master, and thus be propagated to the agents automatically. In an agent's life cycle, here is what goes on:
* Agent generates a key and cert. signing request
* Master signs the agent's certificate
* After this, the agent checks with the master periodically (default every 30 min.) and performs a run of the catalog each time to check the sync. state of all the contained resources.
* At some point, an agent might be taken out of service. When this happens, its cert. should be invalidated.

## Renewing an agent's certificate

This is a pretty long (but straightforward) process. At a high level, you delete the agent-side of the cert and then clean the cert on the master, then re-do the initial signing process.

## Completing the stack with PuppetDB

PuppetDB is a specialized database REST API designed to interact with the Puppet master. It has a PostgreSQL backend with an API wrapper, the latter of which was written in Clojure. PuppetDB helps the master store reports and any other agent data; it's also necessary for some specific manifest compiler functionality.
